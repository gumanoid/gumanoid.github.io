---
layout: post
title:  "CompletableFuture"
date:   2017-09-01 23:59:59 +0400
categories: jekyll update
---

Эта статья нанесёт непоправимую ясность в вопросе `java.util.concurrent.CompletableFuture`. До понимания назначения `CompletableFuture` осталось 8 предложений.

Возьмём типичную задачу: "после того, как файл будет загружен, показать пользователю уведомление". Как выразить в коде отношение "**после того, как**"? В простом однопоточном случае это отношение и задаётся просто - порядком вызова методов:

    uploadFile();
    showNotification();

В реальном приложении всё сложнее. Часть шагов выполняется последовательно в одном потоке, часть - параллельно в разных потоках. Шагов намного больше двух, и они связаны друг с другом по данным: результат шага может быть входным параметром для других шагов. Эти связи по данным - ни что иное, как отношение **после того, как**: выполнение шага может быть начато только тогда, когда все его входные параметры вычислены.

Назначение `CompletableFuture` - выразить в коде, что после чего вычисляется, в суровой многопоточной реальности. Вот как перепишется наш пример:

    CompletableFuture<Void> whenFileUploaded = CompletableFuture.runAsync(() -> uploadFile());
    CompletableFuture<Void> whenNotificationShown = whenFileUploaded.thenRun(() -> showNotification());

Получилось громоздко из-за длинного названия класса. Зато исходная задача выражена почти естественным языком: `whenFileUploaded.thenRun(() -> showNotification())`. К тому же код можно сократить, воспользовавшись тем фактом, что почти все методы `CompletableFuture` возвращают тоже `CompletableFuture`:

    CompletableFuture.runAsync(() -> uploadFile())
                     .thenRun(() -> showNotification());

Итак, какую задачу решает `CompletableFuture`, разобрались. Всё, статью можно закрывать? Нееет, мы только начали. Множество нюансов ещё предстоит раскрыть. Основные их категории:
* указание потока, в котором будет выполняться шаг
* передача данных от одного шага к другому
* обработка исключений
* схема именования методов `CompletableFuture`, без которой легко заблудиться в десятках его методов
* перевод существующего однопоточного кода на использование `CompletableFuture`
* ограничения идеи и реализации `CompletableFuture`
* сдвиг парадигмы, или обновление ментальной модели кода

Начнём с потоков. Наши варианты:
* синхронно - следующий шаг выполняется в том же потоке, что и предыдущий
* асинхронно, поток указывается явно
* асинхронно, использовать системный `ForkJoinPool.commonPool`
* выбор потока делегируется вызываемому методу

Вернёмся к нашему примеру:

    CompletableFuture.runAsync(() -> uploadFile())       //асинхронно в ForkJoinPool.commonPool
                     .thenRun(() -> showNotification()); //синхронно в том же потоке

"Async" в конце имени метода указывает, что шаг будет выполняться асинхронно. У каждого из таких методов есть две перегрузки, одна из которых принимает последним параметром явно указанный поток. Точнее, не поток, а `java.util.concurrent.Executor` - абстракцию "контекст исполнения" с единственным методом:

    interface Executor {
        void execute(Runnable command);
    }

Перепишем наш пример с явным указанием контекстов исполнения:

    Executor threadPool = Executors.newFixedThreadPool(2);
    Executor sameThread = (Runnable r) -> r.run(); //или ещё короче: sameThread = Runnable::run;
    CompletableFuture.runAsync(() -> uploadFile(), threadPool)
                     .thenRunAsync(() -> showNotification(), sameThread);

Шаг `uploadFile` мы отправили выполняться в пул из двух потоков, созданный с помощью фабричного метода из класса `java.util.concurrent.Executors`. В этом классе определены несколько фабрик для наиболее распостранённых случаев.

Контекст исполнения шага `showNotification()` другой. Это простейшая реализация интерфейса `Executor` - он просто запускает переданную ему команду на выполнение, прямо в потоке, который вызвал метод `execute`. На практике он малоприменим, и приведён лишь для иллюстрации того факта, что `Executor` не обязан запускать код в отдельном потоке.

`ForkJoinPool.commonPool`, который используется, если методу `...Async` не указали контекст исполнения явно - это системный пул потоков. Важная его особенность - он предназначен для вычислительных задач, и не подходит для операций ввода-вывода. Он один на JVM, поэтому использовать его нужно аккуратно, чтобы не создавать лишних неявных связей между частями системы.

Наконец, вызываемый метод может самостоятельно решать, в каком контексте ему выполняться. Например, синхронно:

    CompletableFuture<Void> doUploadFile() {
        uploadFile();
        return CompletableFuture.completedFuture(null);
    }

Или асинхронно в контексте, который снаружи не виден:

    private final Executor uiThread = SwingUtilities::invokeLater;
        
    public CompletableFuture<Void> doShowNotification() {
        return CompletableFuture.runAsync(() -> showNotification(), uiThread);
    }

Или динамически выбирать контекст:

    public CompletableFuture<Void> doShowNotification() {
        final CompletableFuture<Void> result;
        if (SwingUtilities.isEventDispatchThread()) {
            showNotification();
            result = CompletableFuture.completedFuture(null);
        } else {
            result = CompletableFuture.runAsync(() -> showNotification(), uiThread);
        }
        return result;
    }

Исходный пример можно переписать так:

    doUploadFile().thenCompose(__ -> doShowNotification());

Почему `thenCompose`, а не `thenRun`? Пора поговорить о схеме именования методов `CompletableFuture`.

Примерно половина методов именуется по схеме: `then`; затем `Accept`/`Apply`/`Compose`/`Run`; затем, опционально, `Async`. Что означает `Async`, мы уже разбирали выше - это указание, что шаг будет выполняться в отдельном потоке. `Accept`/`Apply`/`Compose`/`Run` выбирается исходя из того, что принимает на вход и что возвращает очередной шаг.

`Run`: входного параметра у шага нет, возвращаемого значения тоже. Такое мы видели в примере выше:

    whenFileUploaded.thenRun(() -> showNotification());

`Accept`: есть входной параметр, возвращаемгого значения нет. Пример:

    CompletableFuture<String> greeting = CompletableFuture.completedFuture("Hello world!");
    greeting.thenAccept(helloWorld -> System.out.println(helloWorld));

`Apply`: есть входной параметр и возвращаемое значение любого типа, кроме `CompletableFuture`:

    CompletableFuture.completedFuture("Hello")
                     .thenApply(part1 -> part1 + " world!")
                     .thenAccept(greeting -> System.out.println(greeting));

`Compose`: есть входной параметр и возвращаемое значение типа `CompletableFuture`:

    CompletableFuture.completedFuture("Hello")
                     .thenCompose(part1 -> CompletableFuture.completedFuture(part1 + " world!"))
                     .thenAccept(greeting -> System.out.println(greeting));

А как быть, если нет входного параметра, но есть возвращаемое значение? Прикинуться, что входной параметр есть, но не использовать его: `.thenApply(__ -> returnValueImmediately())` или `.thenCompose(__ -> returnValueLater())`.





Почти все проблемы многопоточного программирования сводтся к тому, что какой-то код выполнен **не тогда, когда надо** - слишком рано или слишком поздно (например, никогда, т. е. вовсе не выполнился).

Нюансы вот:
* как передать результат предыдущего шага на вход следующему?
 * как сигнализировать об ошибках?
* как задать последовательность шагов?
 * что, если для выполнения шага нужно дождаться несколько предыдущих?
 * что, если после выполнения шага нужно запустить несколько следующих?
* в каком потоке будет выполняться шаг?
 * выбор потока происходит внутри выполняемого шага, или снаружи?
 * шаг может выполняться в том же потоке, что и предыдущий

`CompletableFuture` позволяет учесть всё это, причём в единообразном интерфейсе.

Про обработку ошибок нужно сказать отдельно, а потом три раза повторить - для тех, кто ещё не отвык от однопоточного программирования. **В многопоточном программировании просто не работают некоторые из инструментов, к которым мы очень привыкли - настолько, что считаем их само сабой разумеющимися**:
* try-блок. try-блок в родительском потоке не поймает исключения в дочернем потоке. Такие исключения нужно сначала поймать в дочернем, а потом вручную передать в родительский. Мы привыкли, что можно бросить исключение в глубоко вложенном методе - и рантайм гарантирует, что это исключение прервёт все методы уровнем выше без catch-блока, и что это исключение не будет проигнорировано, как это было легко сделать с кодами ошибок в Си. Но когда для выполнения задачи нужно координировать несколько потоков, объекты-ошибки нужно передавать между ними как-то иначе. Дочерний поток зачастую ловит все исключения, вплоть до `Throwable`. Если какое-то исключение пропустить, не просигналив о нём родительскому потоку, он в лучшем случае продолжит по таймауту, так и не узнав причину сбоя (что важно), либо будет ждать вечно.
* Отдельные catch-блоки под разные классы исключений. Родительский поток, как правило, получает сигнал об ошибке в дочернем в виде Throwable. Дальнейшая сортировка по классу делается серией `instanceof`, пока в java не завезли pattern matching.
* finally-блок. В однопоточном случае finally даёт сразу две гарантии: во-первых, он выполнится в любом случае, даже если было исключение, во-вторых, он выполнится **после** try-блока. Вот это гарантированное "**после**" в многопоточном случае требует дополнительных усилий.
* Cтэктрейс. Теперь одного стэктрейса недостаточно, чтобы понять, в каком порядке были вызваны методы в разных потоках. Если при этом замешано изменяемое состояние, бывает почти невозможно разобраться в последовательности изменений. Спасают неизменяемые объекты.

Вишенка на торте, которая есть только в java - проверяемые (checked) исключения, которые плохо сочетаются с функциональными интерфейсами из JDK. Одно из таких исключений, IOException, видимо, настолько путалось под ногами, что теперь в JDK есть класс UncheckedIOException.



Так вот: шок! поддержка исключений в java работает **исключительно** в однопоточном коде.

Конечно, это утверждение слишком категорично, чтобы быть точным. Но оно недалеко от истины. При переходе от однопоточного программирования к многопоточному безопасней исходить из того, что язык вам больше никак не помогает обрабатывать исключения. У вас больше нет:
* Стектрейсов. Стек существует в рамках одного потока. 



Уже не помню, при каких обстоятельствах я впервые заинтересовался классом java.util.concurrent.CompletableFuture. Помню свою первую реакцию.

TODO Гифка. Скриншот Идеи с текстом 'new CompletableFuture()', нажимается точка, выпрыгивают десятки методов класса. Соединить с гифкой, где кто-нибудь открывает изнутри дома входную дверь, и в него вваливается сугроб.

Первая мысль при виде полусотни методов: "С названием класса ошиблись. Этот Future не Completable, он какой-то Complicated". И на какое-то время я забыл про этот класс.

Со второго захода разобраться удалось. С другими классами это получается, как правило, за счёт понимания, что это такое и зачем нужно. В случае CompletableFuture просветление настигло в тот момент, когда я осознал, что среди этих десятков методов много почти одинаковых, они логически группируются в небольшой набор операций. Практически каждая операция принимает на вход лямбду и возвращает CompletableFuture. Одной операции может соответствовать 12 (!) методов: 4 варианта лямбды и 3 варианта асинхронности. Потратив чуть-чуть времени на то, чтобы запомнить схему именования методов, можно существенно облегчить себе понимание.

CompletableFuture - это способ разделить два аспекта: *что* вычисляется и *кем* (в каком потоке) вычисляется. Для примера возьмём вот такой код:

    try {
        Type1 var1 = computeFirstStage();
        Type2 var2 = computeSecondStage(var1);
        Type3 var3 = computeThirdStage(var1, var2);
        System.out.println(var3);
    } catch (Exception error) {
        error.printStackTrace();
    }

Тот же код с использованием CompletableFuture выглядит так:

    CompletableFuture<Type1> future1 = CompletableFuture.supplyAsync(() -> computeFirstStage());
    CompletableFuture<Type2> future2 = future1.thenApply(var1 -> computeSecondStage(var1));
    CompletableFuture<Type3> future3 = future1.thenCombine(future2, (var1, var2) -> computeThirdStage(var1, var2));
    CompletableFuture<Type3> future4 = future3.whenComplete((value, error) -> {
        if (error == null) {
            System.out.println(value);
        } else {
            error.printStackTrace();
        }
    });



:
- создание экземпляра CompletableFuture
- преобразоване одного экземпляра в другой
- преобразование двух и более экземпляров в один
- указание реакции на завершение (получение значения/ошибки)
- вспомогательные методы


CompletableFuture<T> - контейнер на одно значение, который может находиться в одном из трёх состояний:
- пусто
- содержит T
- содержит Throwable

Возможен переход из состояния "пусто" в состояние "содержит T" или "содержит Throwable", и только (есть нюанс, но о нём позже).



-- Function
-- Consumer
-- Runnable
-- без постфикса Async
-- \*Async с явным указанием Executor'а
-- \*Async без указания Executor'а


